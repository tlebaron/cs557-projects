\section{Introduction}
This project aims to demonstrate our knowledge on code-reuse attacks. After code injection attacks, defenses like the NX bits has been developed. In this case, it enforce the fact that code passed on the stack or the heap should never be executed, since it should just be used to store in memory. With stack and heap not executable, we can not execute injected shellcode. The idea of code-reuse attack is to execute code already existing, code we did not inject. The basic code-reuse attack is to execute the system() function of the libc by passing the "/bin/sh" argument on the stack (only works on 32 bits). A more interesting subclass of code-reuse attack is named return oriented programing (ROP). It uses the fact that the control flow can jump in the middle of any kind of existing function to only executed what is needed. For instance, calling system("/bin/sh") on 64 bits means first loading the "/bin/sh" address in the right register and then jump to system(). Loading a register like rdi needs only a pop rdi instruction since we assume the attacker can take control of the content of the stack. Therefore, an attacker needs only to jump to a pop instruction into rdi followed by a return address. By writing the address of system() on the stack, the "gadget" (pop instruction and return) will simply load whatever the attacker wrote at the top of the stack into rdi before returning at the system() function.
This paper explain how we used this type of attack to get privilege escalation on a code with a simple vulnerability, the format string vulnerability. This vulnerability is not used to overwrite a return address. As a result, the canaries added at compiler time do not prevent our attack in any way. Nevertheless, we had to disble the ASLR protection to keep this exploit easily understandable.
