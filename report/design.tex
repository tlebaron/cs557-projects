\section{Design}
\emph{access\_to\_the\_peanutcave\_reboot} is a binary which involves a series of three challenges that need to be correctly completed in order to enter the secret peanut cave. The inner part of the cave gives great power to anyone who can reach it (launch \emph{/bin/shh} using execve to gain privilege escalation for instance). The main idea of this challenge is to show that implementing a series of weak protection is not enough to secure a program. On top of the protections added to this binary, the stack canaries and ASLR are enabled.

The three locks are the following:

\begin{itemize}
  \item \textbf{Random password:} To enter the inner room, the user have to enter a correct password. By design, the password should be random since generated by the \emph{rand()} function.

  \item \textbf{File IO:} To even enter the password, the user needs to point the program to the right input.
    
  \item \textbf{No arbitrary execution:} The executed instruction depends of the value used to point to the correct input (step 2) to enter the password. Therefore, the user shouldn't by able to execute an arbitrary instruction.
\end{itemize}

\subsection {Lock 1: Random password}
Our first lock was inspired by a CTF binary challenge named \emph{random} on pwnable.kr. In \emph{access\_to\_the\_peanutcave\_reboot} we ask for a key and then perform an \emph{XOR} with a key that we ''randomly'' generated using the rand function and compare it to the value {\tt0x9000ddo9} (goood dog). 

The core of the vulnerability comes from our incorrect usage of the \emph{rand()} function. We forgot to actually seed our random function! As a result, it will be given the default seed of 0. This means that we can easily create a separate script that calls rand the same way, and gets the same ''random'' number. This will allow us to get the correct value to open this lock. 

\subsection{Lock 2: File IO Lock}
Our second lock was inspired by a CTF binary challenge named \emph{fd} on pwnable.kr. This lock uses an argument passed to the main function, and subtracts a particular key from it before utilizing it as the file descriptor for a read operation. The trick to this lock is that if the read function is passed a file descriptor of 0, it will read from stdin by default. This will then allow the attacker to input the correct password to access execve.

\subsection{Lock 3: Time of Check, Time of Use Lock}
Our third lock was our own design to utilize a classic buffer overflow to overwrite a value before it is used. In this case, we call \emph{execve()} with the values of \emph{buffer2} (which is set to be the same as \emph{argv[1]}). However, \emph{argv[1]} was utilized early in the program and needed to be set to a particular value in order to pass lock 2. Not a problem! We have a \emph{gets()} call on a buffer allowing for a buffer overflow. This allows us to overflow into \emph{buffer2} and set the value to be ''/bin/shh'' in between when it is used to open lock 2, and when it is used in our third lock to call \emph{execve()}. 
