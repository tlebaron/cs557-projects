\section{Exploitation}
Our exploit involves a set of 4 different inputs in order to break each successive lock. The combination of these inputs allows us to break through the three layers of locks in order to launch a shell with privilege escalation. 

\subsection{Before program execution}
Before the start of program execution there are several steps that need to be taken. First, we must find what the value of random is going to be. The easiest way of doing this is to create a program which simply creates a random number using rand and prints it out. In our case, we used a file called test.c to do this, the code for doing so is in lines 8-10 in our test.c file. Once we get that value (NUMBER FROM RANDOM) we can perform and XOR with {\tt 0x9000dd0g} from line 21 in our challenge binary (the first lock we need to break) in order to get a value we will need later in execution. That number turns out to be NUMBER.

We will also need to use GDB to disassemble the code in order to grab the locations of buffer and buffer2 so that we can know how much padding we need in order to overflow the correct value into buffer2 if we don't want to run the program multiple times. Alternatively, we found our padding simply by running the program once with strace and seeing what was passed to execve. 

In addition, when we are calling the program we will need to give it an argument equal to 0x1234 (from line 23 of our challenge program) so that eventually when the program grabs a file descriptor, we will have an fd of 0 allowing us to read from stdin and break the second lock.

\subsection{During program execution} 
When the program is running, there will be three prompts. On the first prompt, we have to input the value we got from XORing rand earlier, NUMBER. This will result in the comparison being true, and will open the first lock. 

For the second lock, our program will already have pulled argv[1] and, if it was set to the correct number, the read function is now reading from stdin. Thus we just now need to provide it with the string it is expecting to read from the file. In this case as we see on line 27 of our challenge program that the value it is looking for is {\tt ILOVEPEANUT}. When we input that into the prompt, we will pass the second lock.

Finally, we will need to make sure that buffer2, which will automatically copy the value in argv[1] (0x1234) is set to be /bin/shh instead. In order to do that, we have to do a buffer overflow. We could do that by coming through the disassembly before we begin (as previously stated), however in our case we just supplied an input of ``AAAABBBBCCCC...'' and then using strace to see what was passed to execve. Using this method we found that we needed a buffer of size X before inputting /bin/shh. We then redid our execution and put in out correct buffer and /bin/shh on the third prompt. This successfully launches a shell.