\section{Design}
\subsection{Format string vulnerability}
The core of our vulnerability exists in that in the fuction Peanut we pass an arbitrary buffer of user input (gathered using fgets) to the function printf (line 9 of our c code: {\tt printf(buffer)}). This introduces a format string vulnerability that will allow us to "Write What Where" using the special format string \%n. In our exploit, we will use this vulnerability to overwrite the Global Offset Table (GOT).
\subsection{Exit and the Global Offset Table}
Our vulnerable function, Peanut contains a call to Exit before the end (line 11 of our c program: {\tt exit(1)}) . This means that we cannot overwrite the return pointer since the return pointer will never be called (we will exit before then). However, exit will be called from the Global Offset Table. This means that if we can overwrite the address to exit in the GOT, we will be able to redirect the programs control flow
\subsection{execve}
In order give a big "Look over here" hint as well as make our exploit easier, we have embedded the arguments to call execve onto the stack in our main function (lines 22-24). This will make it easier to call bin shh from execve. We believe that it could also be called by embedding those arguments in the buffer. 

Note that we did explore calling mprotect to make the stack executible to call our shell code instead of calling execve directly using gadgets. While we got this working in GDB, we could not do so outside of the debug environment as mprotect needed to know the exact start of the stack page and it's exact size in order to work correctly, and we were unable to find this information with our avaliable program. This is something we would like to attempt again in future work.