\section{Exploitation}
The buffer we used to execute {\tt execve("/bin/shh")} has the following contruction:

{\tt \small
\begin{verbatim}
+---------+  ^
| %x & %n |  |  stack
| three   |  |  grows
| times   |  |  this way
+---------+  +
|   ROP   |
|  chain  |
+---------+
| padding |
| optional|
+---------+
|  exit   |
|addresses|
+---------+
\end{verbatim}
}

We explain step by step how to construct the exploit in this section.
\subsection{Format String Exploit}
The core of our exploit involves the fact that printf prints a buffer of user input. This is a vulnerability which allows us to use special string formatting characters as input in order to create malicious affects on the system. In particular, we can use \%x and \%n. 

The special format specifier \%n allows us to print the number of characters printed into a particular location. This will allow us to have a write what where vulnerability (woo hoo!). In our case, we will use this to overwrite the value of the global offset table so that when exit is called, it will eventually call our overwritten address instead. In order to do that we first need to find out what address we need to overwrite. We do that by debugging through our code in order to find the location of the global offset table.  We see that the function called is {\tt <exit@plt>}, which jumps directly to another address, which is the place in the GOT which store the real address of exit(). In our case, this address is {\tt 0x601030}. This is what we need to overwrite with our first gadget. We can put this value into our buffer and then reference it as our write location. 

We can then try overwriting that writing location by printing (using printf) a number of blank spaces equal to the address, and then writing that as a hexidecimal representation (\%x) to our specified address using \%n. But wait, addresses in libc are really big, which is a lot of printing of extra characters. When we tried this as a single call it did not work. As a result, we decided to break up our write into 3 segments where we write 4 hexidecimal values each. Note that we do not have to write 4 of the values since the topmost values are 0s both for the original address, and for our gadgets in libc. In order for this to work, however, we had to print the values in order from least to greatest, so that we were printing progressively more spaces and the moving that value of already printed spaces into the correct places.

When executing the \%n specifiers which point to the exit addresses, the printf() function will overwrite the entry in the GOT table. We needed to write the address {\tt 0x7ffff7b49c0e} at the address {\tt 0x601030} (see subsection on exit address). We write this adress in three times, in the following order:
\begin{enumerate}
\item {\tt 0x7fff} at {\tt 0x601034}
\item {\tt 0x9c0e} at {\tt 0x601030}
\item {\tt 0xf7b4} at {\tt 0x601032}
\end{enumerate}
Since \%n write the number of printed characters since the beginning of the execution of printf(), we need to write the address in the increasing order of their values. Because the position of the addresses of exit on the stack where from the 67th to the 69th and we only want to write 2 bytes, then the exploit must start with:

{\tt \small
\begin{verbatim}
exploit = ""
exploit += " %{}x ".format(0x7fff)
exploit += " %67$hn "
exploit += " %{}x ".format(0x9c0e - 0x7fff)
exploit += " %68$hn "
exploit += " %{}x ".format(0xf7b4 - 0x9c0e)
exploit += " %69$hn "
\end{verbatim}
}

A few change in the numerical values must be performed to take in account that we print spaces with the specifiers.

\subsection{Poppin'}
But what do we overwrite it with? At first, we tried to do a simple pop to any register and then a return (as the exit command itself with push 0x1 onto the stack). We were then put our shell code before our printf writing vulnerability in our code, so that when our gadget returned, it would immediately start executing the rest of our shell code gadgets. However, when we did that, we immediately went from correctly overwriting the address to nothing happening. Upon further reflection this was because our gadget addresses had null bytes and printf stops printing when it encounters a null terminator. What a pain! 

So instead of doing just a simple pop, we instead put the shellcode AFTER our printf exploit (although before the reference address for our overwriting since we did not need that inside the exploit). We were then able to find a gadget which performed seven consequtive pops and then returned. This allowed us to pop off our printf exploit call and the 0x1 pushed onto the stack from the exit code so that we would then return and grab the next gadget address as our return pointer. 

\subsection{Execve call}
Once we successfully grabbed control of the program, we then had to use gadgets to call execve since we had a non-executable stack. Since we already had the parameters we needed in main, it was easy to grab the addresses for the parameters that execve needed. We found gadgets to pop them into the correct registers and placed them onto the stack such that they would be correctly popped off. We then called execve on bin shh in order to launch a shell.

By writing the {\tt execve("/bin/shh")} code in C and looking at the assembly, we list the content of the registers we need to set up.
\begin{enumerate}
\item rax: execve code, 0x3b.
\item rdi: address of "/bin/shh" string, needs to be followed by a null byte.
\item rsi and rdx: 0x0.
\end{enumerate}
The implementation of the ROP chain in the exploit buffer is as followed:
{\tt \small
\begin{verbatim}
exploit += <pop rax address>
exploit += 0x000000000000003b
exploit += <pop rdi address>
exploit += <address of "/bin/shh">
exploit += <pop rsi address>
exploit += 0x0000000000000000
exploit += <pop rdx address>
exploit += 0x0000000000000000
\end{verbatim}
}
We used the struct package and its pack() function in our exploit to implement this ROP chain.


\subsection{Padding}
Padding to cover the whole buffer is optional but useful when creating the exploit. If we need to add something before the exit addresses, their position will change and we will need to start again, determining their position to point at it again. With a padding, the position of the exit addresses will stay the same whatever we append to the exploit buffer before padding. We implemented the padding as follow:
\begin{verbatim}
def pad(s):
	return s+X*(buffer_size - len(s)
             - exit_addresses_size)
exploit = pad(exploit)
\end{verbatim}

\subsection{Mprotect}
Initially we had not planned to launch execve via gadgets, but instead had planned to call mprotect to change the permissions on the stack to allow execution. We managed to place the gadgets on the stack in a similar way to our execve call, and then had a jump to the middle of our NOP slide for shellcode execution. Unfortunately, while this worked perfectly within GDB, outside of GDB we were not able to get this working. This is because GDB allows you to see the exact location of the stack and it's size which we needed for the mprotect call. Despite turning off ASLR, the location seemed to be different outside of the stack, and while we tried various ways in order leak the information through our printf statement, we were not able to get an accurate enough location for the stack in order to get mprotect to work. As a result, this was abandoned in favor of simply using gadgets to call execve. We hope to explore this more in the future. 



